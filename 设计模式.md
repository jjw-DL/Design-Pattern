# 面向对象设计8大原则

-   **依赖倒置原则（DIP）**
    -   高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该<font color='red'>依赖于抽象(</font>稳定) 
    -   抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)
-   **开放封闭原则（OCP）**
    -   **对<font color='red'>扩展</font>开放，对<font color='red'>更改</font>封闭**
    -   类模块应该是可扩展的，但是不可修改

-   **单一职责原则（SRP）**
    -   **一个类应该仅有一个引起它变化的原因**
    -   变化的方向隐含着类的责任

-   **Liskov 替换原则（LSP）**
    -   子类必须能够替换它们的基类(IS-A)
    -   继承表达类型抽象

-   **接口隔离原则（ISP）**
    -   不应该强迫客户程序依赖它们不用的方法
    -   接口应该小而完备

-   <font color='red'>优先使用对象组合，而不是类继承</font>
    -   类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
    -    继承在某种程度上破坏了封装性，子类父类耦合度高
    -   而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低
    
-   **封装变化点**
    -   使用封装来创建对象之间的分界层，让设计者可以**在分界层的**一侧进行修改，而不会对另一侧产生不良的影响，从而实现层
        次间的松耦合。（高级的封装是变化点的封装）
    
-   **针对接口编程，而不是针对实现编程**
    -    不将变量类型声明为某个特定的具体类，而是声明为某个接口
    -    客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
    -    减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案

# GOF-23 模式分类

>   从目的来看

-   创建型（Creational）模式：将对象的部分**创建工作延迟**到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
-   结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
-   行为型（Behavioral）模式：通过类继承或者对象组合来划**分类与对象间的职责**，从而应对需求变化为多个交互的对象带来的冲击。

>   从范围来看

-   **类模式**处理类与子类的**静态**关系
-   **对象模式**处理对象间的**动态**关系

# 从封装变化角度对模式分类

![image-20210310091946193](https://i.loli.net/2021/03/10/3wjGrHo8Uxc5eNI.png)

# 重构获得模式 Refactoring to Patterns

-   面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足 “**应对变化，提高复用**”的设计 。
-   现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“**寻找<font color='red'>变化点</font>，然后在变化点处应用设计模式**，从而来更好地应对需求的变化”.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
-   设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“**Refactoring to Patterns**”是目前普遍公认的最好的使用设计模式的方法。

## 重构关键技法

-  **静态		 动态**

- **早绑定 	晚绑定**
- **继承		 组合**
- **编译时依赖	运行时依赖**
- **紧耦合		松耦合**

# “组件协作”模式

现代软件专业分工之后的第一个结果是“**框架与应用程序**的划分”，“组件协作”模式通过**晚期绑定**，来实现框架与应用程序之间的**松耦合，**是二者之间协作时常用的模式。

>    典型模式

-   Template Method
-   Observer / Event
-   Strategy

##  Template Method 模式

### 动机（Motivation）

-   在软件构建过程中，对于某一项任务，它常常有**稳定**的整体操作结构，但各个子步骤却有很多**改变**的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。
-   如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

### 结构化软件设计流程

![image-20210310102919666](https://i.loli.net/2021/03/10/5u6EBKZYoyhHDtO.png)

### 面向对象软件设计流程

![image-20210310102946664](https://i.loli.net/2021/03/10/4PBCTadmFyI2uvr.png)

### 早绑定与晚绑定

![image-20210310103018355](https://i.loli.net/2021/03/10/G87yRSXEMwAn9HB.png)

### 模式定义

定义一个操作中的算法的**骨架 (稳定)**，而将一些**步骤延迟**(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可**重定义(override 重写)**该算法的某些特定步骤。

### 结构

![image-20210310103452496](https://i.loli.net/2021/03/10/jAnrfysOP2DeZF7.png)

### 要点总结

-   Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（**虚函数的多态性**）
    为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
-   除了可以灵活应对子步骤的变化外，“**不要调用我，让我来调用你**”的反向控制结构是Template Method的典型应用。
-   在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将
    它们**设置为protected方法**。（因为这类方法都是对本来方法有所依赖的，设置为public供外界单独调用意义不大）

### 伪码演示

>   结构化软件设计

```c++
//程序库开发人员
class Library{

public:
	void Step1(){
		//...
	}

    void Step3(){
		//...
    }

    void Step5(){
		//...
    }
};
```

```c++
//应用程序开发人员
class Application{
public:
	bool Step2(){
		//...
    }

    void Step4(){
		//...
    }
};

int main()
{
	Library lib();
	Application app();

	lib.Step1();

	if (app.Step2()){
		lib.Step3();
	}

	for (int i = 0; i < 4; i++){
		app.Step4();
	}

	lib.Step5();

}
```

>   面向对象软件设计

```c++
//程序库开发人员
class Library{
public:
	//稳定 template method
    void Run(){
        
        Step1();

        if (Step2()) { //支持变化 ==> 虚函数的多态调用
            Step3(); 
        }

        for (int i = 0; i < 4; i++){
            Step4(); //支持变化 ==> 虚函数的多态调用
        }

        Step5();

    }
	virtual ~Library(){ }

protected:
	
	void Step1() { //稳定
        //.....
    }
	void Step3() {//稳定
        //.....
    }
	void Step5() { //稳定
		//.....
	}

	virtual bool Step2() = 0;//变化
    virtual void Step4() =0; //变化
};
```

```c++
//应用程序开发人员
class Application : public Library {
protected:
	virtual bool Step2(){
		//... 子类重写实现
    }

    virtual void Step4() {
		//... 子类重写实现
    }
};




int main()
	{
	    Library* pLib=new Application();
	    lib->Run();

		delete pLib;
	}
}
```

## Strategy 策略模式

**真正的复用**是**二进制中的复用**，不是**代码粘贴复用**，在原有代码后面添加代码，有可能导致前面的代码需要修改，从而引入新的bug，推荐使用扩展的方式修改程序，而不是更改的方式进行修改，要尽量**符合“开闭原则”**。

### 动机（Motivation）

-   在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
-   如何在运行时根据需要透明地更改对象的算法？**将算法与对象本身解耦**，从而避免上述问题？

### 模式定义

定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

### 结构（Structure）

![image-20210310110724198](https://i.loli.net/2021/03/10/7ohtuCT62KFWkgN.png)

### 要点总结

-   Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
-   Strategy模式提供了**用条件判断语句**以外的另一种选择，消除条件判断语句，就是在解耦合。**含有许多条件判断语句的代码通常都需要Strategy模式。**
-   如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

### 伪码演示

>   if-else模式

```c++
enum TaxBase {
	CN_Tax,
	US_Tax,
	DE_Tax,
	FR_Tax       //更改
};

class SalesOrder{
    TaxBase tax;
public:
    double CalculateTax(){
        //...
        
        if (tax == CN_Tax){
            //CN***********
        }
        else if (tax == US_Tax){
            //US***********
        }
        else if (tax == DE_Tax){
            //DE***********
        }
		else if (tax == FR_Tax){  //更改
			//...
		}

        //....
     }
    
};
```

>   策略模式

```c++
class TaxStrategy{
public:
    virtual double Calculate(const Context& context)=0;
    virtual ~TaxStrategy(){}   // 基类析构函数要用虚函数
};


class CNTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class USTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class DETax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};



//扩展
//*********************************
class FRTax : public TaxStrategy{
public:
	virtual double Calculate(const Context& context){
		//.........
	}
};


class SalesOrder{
private:
    TaxStrategy* strategy;

public:
    SalesOrder(StrategyFactory* strategyFactory){
        this->strategy = strategyFactory->NewStrategy();
    }
    ~SalesOrder(){
        delete this->strategy;
    }

    public double CalculateTax(){
        //...
        Context context();
        
        double val = 
            strategy->Calculate(context); //多态调用
        //...
    }
    
};
```

## Observer 观察者模式

### 动机（Motivation）

-   在软件构建过程中，我们需要为某些对象建立一种**“通知依赖关系”** ——一个对象（目标对象）的状态发生改变，所有的依赖对
    象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
-   使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

### 模式定义

-   定义对象间的**一种一对多（变化）**的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

### 结构（Structure）

![image-20210311105200814](https://i.loli.net/2021/03/11/93ALCpWnkyEoDJP.png)

### 要点总结

-   使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
-   **目标发送通知时，无需指定观察者**，通知（可以携带通知信息作为参数）会**自动传播**。
-   观察者自己决定是否需要订阅通知，目标对象对此一无所知。
-   Observer模式是**基于事件**的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。

### 伪码演示

>   紧耦合文件分割器进度条显示

```c++
class FileSplitter
{
	string m_filePath;
	int m_fileNumber;
	ProgressBar* m_progressBar;

public:
	FileSplitter(const string& filePath, int fileNumber, ProgressBar* progressBar) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber),
		m_progressBar(progressBar){

	}

	void split(){

		//1.读取大文件

		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...
			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			m_progressBar->setValue(progressValue);
		}

	}
};
```

```c++
class MainForm : public Form
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;
	ProgressBar* progressBar;

public:
	void Button1_Click(){

		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		FileSplitter splitter(filePath, number, progressBar);

		splitter.split();

	}
};
```

这种设计，当需要增加进度条功能时，两个代码都要更改：**违背了依赖倒置原则（DIP）**

-   MainForm中增加progressBar成员同时传入FileSplitter
-   FileSplitter也增加m_progressBar成员，同时实现进度条显示功能

>   观察者模式

```c++
class IProgress{
public:
	virtual void DoProgress(float value)=0;
	virtual ~IProgress(){}
};


class FileSplitter
{
	string m_filePath;
	int m_fileNumber;

	List<IProgress*>  m_iprogressList; // 抽象通知机制，支持多个观察者
	
public:
	FileSplitter(const string& filePath, int fileNumber) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber){

	}

	void split(){

		//1.读取大文件

		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...

			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			onProgress(progressValue);//发送通知
		}
	}

	void addIProgress(IProgress* iprogress){
		m_iprogressList.push_back(iprogress);
	}

	void removeIProgress(IProgress* iprogress){
		m_iprogressList.remove(iprogress);
	}

protected:
	virtual void onProgress(float value){
		
		List<IProgress*>::iterator itor=m_iprogressList.begin();

		while (itor != m_iprogressList.end() )
			(*itor)->DoProgress(value); //更新进度条
			itor++;
		}
	}
};
```

-   首先，定义观察者接口（IProgress接口）和update方法（DoProgress）
-   在subject（FileSplitter）中定义List<IProgress*>，支持多个观察者
-   实现Attach和Detach（即addIProgress和removeIProgress），实现增加和删除观察者，同时实现Notify（onProgress），循环调用观察者Update方法（DoProgress）

```c++
class MainForm : public Form, public IProgress
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;

	ProgressBar* progressBar;

public:
	void Button1_Click(){

		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		ConsoleNotifier cn;

		FileSplitter splitter(filePath, number);
 
		splitter.addIProgress(this); //订阅通知
		splitter.addIProgress(&cn)； //订阅通知

		splitter.split();

		splitter.removeIProgress(this);

	}

	virtual void DoProgress(float value){
		progressBar->setValue(value);
	}
};

class ConsoleNotifier : public IProgress {
public:
	virtual void DoProgress(float value){
		cout << ".";
	}
};
```

-   c++支持多继承，但是c++不建议使用多继承，正确的使用是单继承（主继承  Form）+  多接口继承（IProgress）
-   在变化的部分，具体实现观察者的update方法（DoProgress）
-   这样做，在添加多种进度条显示功能不用更改FileSplitter这个高层模块

# “单一职责”模式

-   在软件组件的设计中，如果**责任划分的不清晰**，使用继承得到的结果往往是随着需求的变化，**子类急剧膨胀**，同时充斥着重复代码，
    这时候的关键是划清责任。
-   典型模式
    -   Decorator
    -   Bridge

## Decorator 装饰模式

### 动机（Motivation）

-   在某些情况下我们可能会“**过度地使用继承**来**扩展**对象的功能”，由于继承为类型引入的**静态特质**，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
-   如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？

### 模式定义

-   动态**（组合）**地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（**消除重复代码 & 减少子类个数**）。

### 结构（Structure）

![image-20210311115533046](https://i.loli.net/2021/03/11/kiWVHK51moqpRJ8.png)

### 要点总结

-   通过**采用组合而非继承**的手法， Decorator模式实现了在**运行时**动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免
    了使用继承带来的“灵活性差”和“多子类衍生问题”。
-   Decorator类在接口上表现为**is-a Component的继承关系**，即Decorator类继承了Component类所具有的接口。但在实现上又表现为**has-a Component的组合关系**，即Decorator类又使用了另外一个Component类。**(既继承又组合)**
-   Decorator模式的目的**并非解决**“多子类**衍生**的多继承”问题，Decorator模式应用的要点在于**解决**“主体类在多个方向上的**扩展**功能”——是为“装饰”的含义。

### 伪码演示

>   多继承

```c++
//业务操作
class Stream{
public：
    virtual char Read(int number)=0;
    virtual void Seek(int position)=0;
    virtual void Write(char data)=0;
    
    virtual ~Stream(){}
};

//主体类
class FileStream: public Stream{
public:
    virtual char Read(int number){
        //读文件流
    }
    virtual void Seek(int position){
        //定位文件流
    }
    virtual void Write(char data){
        //写文件流
    }

};

class NetworkStream :public Stream{
public:
    virtual char Read(int number){
        //读网络流
    }
    virtual void Seek(int position){
        //定位网络流
    }
    virtual void Write(char data){
        //写网络流
    }
    
};

class MemoryStream :public Stream{
public:
    virtual char Read(int number){
        //读内存流
    }
    virtual void Seek(int position){
        //定位内存流
    }
    virtual void Write(char data){
        //写内存流
    }
    
};

//扩展操作
class CryptoFileStream :public FileStream{
public:
    virtual char Read(int number){
       
        //额外的加密操作...
        FileStream::Read(number);//读文件流
        
    }
    virtual void Seek(int position){
        //额外的加密操作...
        FileStream::Seek(position);//定位文件流
        //额外的加密操作...
    }
    virtual void Write(byte data){
        //额外的加密操作...
        FileStream::Write(data);//写文件流
        //额外的加密操作...
    }
};

class CryptoNetworkStream : :public NetworkStream{
public:
    virtual char Read(int number){
        
        //额外的加密操作...
        NetworkStream::Read(number);//读网络流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        NetworkStream::Seek(position);//定位网络流
        //额外的加密操作...
    }
    virtual void Write(byte data){
        //额外的加密操作...
        NetworkStream::Write(data);//写网络流
        //额外的加密操作...
    }
};

class CryptoMemoryStream : public MemoryStream{
public:
    virtual char Read(int number){
        
        //额外的加密操作...
        MemoryStream::Read(number);//读内存流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        MemoryStream::Seek(position);//定位内存流
        //额外的加密操作...
    }
    virtual void Write(byte data){
        //额外的加密操作...
        MemoryStream::Write(data);//写内存流
        //额外的加密操作...
    }
};

class BufferedFileStream : public FileStream{
    //...
};

class BufferedNetworkStream : public NetworkStream{
    //...
};

class BufferedMemoryStream : public MemoryStream{
    //...
}




class CryptoBufferedFileStream :public FileStream{
public:
    virtual char Read(int number){
        
        //额外的加密操作...
        //额外的缓冲操作...
        FileStream::Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        //额外的缓冲操作...
        FileStream::Seek(position);//定位文件流
        //额外的加密操作...
        //额外的缓冲操作...
    }
    virtual void Write(byte data){
        //额外的加密操作...
        //额外的缓冲操作...
        FileStream::Write(data);//写文件流
        //额外的加密操作...
        //额外的缓冲操作...
    }
};



void Process(){
    //编译时装配
    CryptoFileStream *fs1 = new CryptoFileStream();

    BufferedFileStream *fs2 = new BufferedFileStream();

    CryptoBufferedFileStream *fs3 =new CryptoBufferedFileStream();
}
```

类图关系如下：

![image-20210311114211772](https://i.loli.net/2021/03/11/v3TzqoEhdAN4QcZ.png)

-   可以看出类的数量为：**1 + n + n  *  m / 2**
-   属于编译时装配

>   装饰器方式

```c++
//业务操作
class Stream{

public：
    virtual char Read(int number)=0;
    virtual void Seek(int position)=0;
    virtual void Write(char data)=0;
    
    virtual ~Stream(){}
};

//主体类
class FileStream: public Stream{
public:
    virtual char Read(int number){
        //读文件流
    }
    virtual void Seek(int position){
        //定位文件流
    }
    virtual void Write(char data){
        //写文件流
    }

};

class NetworkStream :public Stream{
public:
    virtual char Read(int number){
        //读网络流
    }
    virtual void Seek(int position){
        //定位网络流
    }
    virtual void Write(char data){
        //写网络流
    }
    
};

class MemoryStream :public Stream{
public:
    virtual char Read(int number){
        //读内存流
    }
    virtual void Seek(int position){
        //定位内存流
    }
    virtual void Write(char data){
        //写内存流
    }
    
};

//扩展操作

DecoratorStream: public Stream{
protected:
    Stream* stream;//...
    
    DecoratorStream(Stream * stm):stream(stm){
    
    }
    
};

class CryptoStream: public DecoratorStream {

public:
    CryptoStream(Stream* stm):DecoratorStream(stm){
    
    }
    
    virtual char Read(int number){
       
        //额外的加密操作...
        stream->Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        stream::Seek(position);//定位文件流
        //额外的加密操作...
    }
    virtual void Write(byte data){
        //额外的加密操作...
        stream::Write(data);//写文件流
        //额外的加密操作...
    }
};



class BufferedStream : public DecoratorStream{
    
    Stream* stream;//...
    
public:
    BufferedStream(Stream* stm):DecoratorStream(stm){
        
    }
    //...
};


void Process(){

    //运行时装配
    FileStream* s1=new FileStream();
    
    CryptoStream* s2=new CryptoStream(s1);
    
    BufferedStream* s3=new BufferedStream(s1);
    
    BufferedStream* s4=new BufferedStream(s2);
}
```

-   **通过继承Stream基类实现接口的规范性，同时组合Stream类实现方法的多态调用**。
-   同时，实现运行时装配，**子类的构造器中传入父类对象**，是典型的构造器实现。

>   其类图如下

![image-20210311114149267](https://i.loli.net/2021/03/11/Nmk17iaOWGFIgYl.png)   

-   可以看出类的数量为：**1 + n + 1 + m** ， 相比继承方式减少了很多
-   **主体操作和扩展操作应该分开分支继承**

## Bridge 桥模式

### 动机（Motivation）  

- 由于某些类型的固有的实现逻辑，使得它们具有**两个变化的维度**，乃至多个纬度的变化。 
- 如何应对这种**“多维度的变化”**？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？  

### 模式定义  

- 将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。  

### 结构（Structure）  

![](https://i.loli.net/2021/03/12/ULZXrEfMOg2Nuaw.png)

### 要点总结

- Bridge模式使用“对象间的**组合关系**”解耦了抽象和实现之间固有的绑定关系，使得**抽象和实现可以沿着各自的维度来变化**。所谓抽象和实现沿着各自纬度的变化即**“子类化”**它们。  
- Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。  
- Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。  

### 伪码实现

> 继承实现

```c++
class Messager{
public:
    // 业务
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;
	// 平台
    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;
    
    virtual ~Messager(){}
};


//平台实现

class PCMessagerBase : public Messager{
public:
    
    virtual void PlaySound(){
        //**********
    }
    virtual void DrawShape(){
        //**********
    }
    virtual void WriteText(){
        //**********
    }
    virtual void Connect(){
        //**********
    }
};

class MobileMessagerBase : public Messager{
public:
    
    virtual void PlaySound(){
        //==========
    }
    virtual void DrawShape(){
        //==========
    }
    virtual void WriteText(){
        //==========
    }
    virtual void Connect(){
        //==========
    }
};



// 业务抽象
// 精简版
class PCMessagerLite : public PCMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        PCMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        PCMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        PCMessagerBase::DrawShape();
        //........
    }
};


// 完美版
class PCMessagerPerfect : public PCMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::DrawShape();
        //........
    }
};


class MobileMessagerLite : public MobileMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        MobileMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        MobileMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        MobileMessagerBase::DrawShape();
        //........
    }
};


class MobileMessagerPerfect : public MobileMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::DrawShape();
        //........
    }
};


void Process(){
        //编译时装配
        Messager *m =
            new MobileMessagerPerfect();
}
```

- 此版本业务和平台实现耦合在一起，通过不同的继承实现，代码存在重复和冗余

> 桥接模式

```c++
class Messager{
protected:
     MessagerImp* messagerImp;//...
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;
    
    virtual ~Messager(){}
};

class MessagerImp{
public:
    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;
    
    virtual MessagerImp(){}
};


//平台实现 n
class PCMessagerImp : public MessagerImp{
public:
    
    virtual void PlaySound(){
        //**********
    }
    virtual void DrawShape(){
        //**********
    }
    virtual void WriteText(){
        //**********
    }
    virtual void Connect(){
        //**********
    }
};

class MobileMessagerImp : public MessagerImp{
public:
    
    virtual void PlaySound(){
        //==========
    }
    virtual void DrawShape(){
        //==========
    }
    virtual void WriteText(){
        //==========
    }
    virtual void Connect(){
        //==========
    }
};


//业务抽象 m

//类的数目：1+n+m

class MessagerLite :public Messager {

    
public:
    
    virtual void Login(string username, string password){
        
        messagerImp->Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        messagerImp->WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        messagerImp->DrawShape();
        //........
    }
};


class MessagerPerfect  :public Messager {
      
public:
    
    virtual void Login(string username, string password){
        
        messagerImp->PlaySound();
        //********
        messagerImp->Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        messagerImp->PlaySound();
        //********
        messagerImp->WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        messagerImp->PlaySound();
        //********
        messagerImp->DrawShape();
        //........
    }
};

void Process(){
    // 运行时装配
    MessagerImp* mImp=new PCMessagerImp();
    Messager *m =new Messager(mImp);
}
```

- **Messager相当于Abstraction包含着接口成员（MessagerImp）**
- Messager和MessagerImp在**两个维度**各自实现

# “对象创建”模式  

- 通过“对象创建” 模式**绕开new**，来**避免**对象创建（new）过程中所导致的紧耦合（**依赖具体类**），从而支持对象创建的稳定。它是接口抽象之后的第一步工作  
- 典型模式  
  - Factory Method  
  - Abstract Factory  
  - Prototype  
  - Builder  

## Factory Method工厂方法  

### 动机（Motivation）  

- 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。  
- 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？  

###  模式定义

- 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化**延迟**（**目的：解耦，手段：虚函数**）到**子类**  

### 结构（Structure）  

![image-20210312200240741](https://i.loli.net/2021/03/12/jUFhqyekiXE7Rmx.png)

### 要点总结  

- Factory Method模式用于**隔离类对象的使用者和具体类型**之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。  
- Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。  
- Factory Method模式解决“单个对象”的需求变化。**缺点在于要求创建方法/参数相同**。  

### 伪码演示

```c++
class ISplitter{
public:
    virtual void split()=0;
    virtual ~ISplitter(){}
};

class BinarySplitter : public ISplitter{
    
};

class TxtSplitter: public ISplitter{
    
};

class PictureSplitter: public ISplitter{
    
};

class VideoSplitter: public ISplitter{
    
};
```

```c++
class MainForm : public Form
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;
	ProgressBar* progressBar;

public:
	void Button1_Click(){
        
		ISplitter * splitter=
            new BinarySplitter();//依赖具体类
        
        splitter->split();

	}
};
```

- splitter以来具体类，已经写死了，不利于将来的扩展

> 工厂方法模式

```c++
// 抽象类
class ISplitter{
public:
    virtual void split()=0;
    virtual ~ISplitter(){}
};


// 工厂基类
class SplitterFactory{
public:
    virtual ISplitter* CreateSplitter()=0;
    virtual ~SplitterFactory(){}
};
```

- ISplitter对应product
- SplitterFactory对应creator
- 二者属于稳定部分

```c++
//具体类
class BinarySplitter : public ISplitter{
    
};

class TxtSplitter: public ISplitter{
    
};

class PictureSplitter: public ISplitter{
    
};

class VideoSplitter: public ISplitter{
    
};

// 具体工厂
class BinarySplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new BinarySplitter();
    }
};

class TxtSplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new TxtSplitter();
    }
};

class PictureSplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new PictureSplitter();
    }
};

class VideoSplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new VideoSplitter();
    }
};
```

- BinarySplitter系列类相当于Concreteproduct
- BinarySplitterFactory系列类相当于ConcreteCreator

```c++
class MainForm : public Form
{
    SplitterFactory*  factory;//工厂

public:
    
    MainForm(SplitterFactory*  factory){
        this->factory=factory;
    }
    
	void Button1_Click(){

        
		ISplitter * splitter=
            factory->CreateSplitter(); //多态new
        
        splitter->split();

	}
};
```

- MainForm只依赖于工厂接口和分割器接口，从而实现了稳定
- 组合接口，在构造函数中传入具体工厂，实现多态调用

## Abstract Factory 抽象工厂  

### 动机（Motivation）  

- 在软件系统中，经常面临着“**一系列相互依赖的对象**”的创建工作；同时，由于需求的变化，往往存在**更多系列对象**的创建工作。  
- 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？

### 模式定义  

- 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。  

### 结构（Structure）  

![image-20210312203513041](https://i.loli.net/2021/03/12/j12ZP9i7RO6GqEm.png)

### 要点总结  

- 如果没有应对“**多系列对象构建**”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以 。
- “系列对象”指的是在某一**特定系列**下的对象之间有**相互依赖、或作用**的关系。不同系列的对象之间不能相互依赖。  
- Abstract Factory模式主要在于应对“新系列”的需求变动。**其缺点在于难以应对“新对象”的需求变动**。  

### 伪码实现

> 简单实现

```c++
class EmployeeDAO{
    
public:
    vector<EmployeeDO> GetEmployees(){
        SqlConnection* connection =
            new SqlConnection();
        connection->ConnectionString = "...";

        SqlCommand* command =
            new SqlCommand();
        command->CommandText="...";
        command->SetConnection(connection);

        SqlDataReader* reader = command->ExecuteReader();
        while (reader->Read()){

        }

    }
};
```

- 数据库连接、发送和读取操作

> 简单工厂实现

```c++
//数据库访问有关的基类
class IDBConnection{
    
};
class IDBConnectionFactory{
public:
    virtual IDBConnection* CreateDBConnection()=0;
};


class IDBCommand{
    
};
class IDBCommandFactory{
public:
    virtual IDBCommand* CreateDBCommand()=0;
};


class IDataReader{
    
};
class IDataReaderFactory{
public:
    virtual IDataReader* CreateDataReader()=0;
};


//支持SQL Server
class SqlConnection: public IDBConnection{
    
};
class SqlConnectionFactory:public IDBConnectionFactory{
    
};


class SqlCommand: public IDBCommand{
    
};
class SqlCommandFactory:public IDBCommandFactory{
    
};


class SqlDataReader: public IDataReader{
    
};
class SqlDataReaderFactory:public IDataReaderFactory{
    
};

//支持Oracle
class OracleConnection: public IDBConnection{
    
};

class OracleCommand: public IDBCommand{
    
};

class OracleDataReader: public IDataReader{
    
};



class EmployeeDAO{
    IDBConnectionFactory* dbConnectionFactory;
    IDBCommandFactory* dbCommandFactory;
    IDataReaderFactory* dataReaderFactory;
    
public:
    vector<EmployeeDO> GetEmployees(){
        IDBConnection* connection =
            dbConnectionFactory->CreateDBConnection();
        connection->ConnectionString("...");

        IDBCommand* command =
            dbCommandFactory->CreateDBCommand();
        command->CommandText("...");
        command->SetConnection(connection); //关联性

        IDBDataReader* reader = command->ExecuteReader(); //关联性
        while (reader->Read()){

        }

    }
};
```

> 抽象工程实现

```c++
// 数据库访问有关的基类
class IDBConnection{
    
};

class IDBCommand{
    
};

class IDataReader{
    
};


class IDBFactory{
public:
    virtual IDBConnection* CreateDBConnection()=0;
    virtual IDBCommand* CreateDBCommand()=0;
    virtual IDataReader* CreateDataReader()=0;
    
};


//支持SQL Server
class SqlConnection: public IDBConnection{
    
};
class SqlCommand: public IDBCommand{
    
};
class SqlDataReader: public IDataReader{
    
};


class SqlDBFactory:public IDBFactory{
public:
    virtual IDBConnection* CreateDBConnection()=0;
    virtual IDBCommand* CreateDBCommand()=0;
    virtual IDataReader* CreateDataReader()=0;
 
};

//支持Oracle
class OracleConnection: public IDBConnection{
    
};

class OracleCommand: public IDBCommand{
    
};

class OracleDataReader: public IDataReader{
    
};



class EmployeeDAO{
    IDBFactory* dbFactory;
    
public:
    vector<EmployeeDO> GetEmployees(){
        IDBConnection* connection =
            dbFactory->CreateDBConnection();
        connection->ConnectionString("...");

        IDBCommand* command =
            dbFactory->CreateDBCommand();
        command->CommandText("...");
        command->SetConnection(connection); //关联性

        IDBDataReader* reader = command->ExecuteReader(); //关联性
        while (reader->Read()){

        }

    }
};
```

- IDBFactory将工厂实现系列化，相当于图中的AbstractFactory
- SqlDBFactory是系列化工厂的具体实现，相当于图中的ConcreteFactory
- SqlConnection和SqlCommand相当于sql这个抽象产品中的productA1和productB1

## Prototype 原型模式

### 动机

- 在软件系统中，经常面临着“**某些结构复杂的对象**”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。
- 如何应对这种变化？如何向”客户程序（使用这些对象的程序）”隔离出“这些易变得对象”。从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变？

### 模式定义

- 使用**原型实例**指定创建对象的种类，然后通过**拷贝**这些原型来创建新的对象

### 结构

![image-20210313075254028](https://i.loli.net/2021/03/13/6KPxfVT3oAj7dpk.png)

要点总结：

- Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”**拥有“稳定接口”**。
- Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活的动态创建“拥有某些稳定接口”的新对象——所需工作**仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone**。
- Prototype模式中的Clone方法可以利用某些框架中的**序列化**来实现深拷贝。

### 伪码实现

```c++
//抽象类
class ISplitter{
public:
    virtual void split()=0;
    virtual ISplitter* clone()=0; //通过克隆自己来创建对象
    
    virtual ~ISplitter(){}

};
```

- ISplitter通过克隆自己来创建对象，不在需要专门的工厂来创建

```c++
//具体类
class BinarySplitter : public ISplitter{
public:
    virtual ISplitter* clone(){
        return new BinarySplitter(*this);
    }
};

class TxtSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new TxtSplitter(*this);
    }
};

class PictureSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new PictureSplitter(*this);
    }
};

class VideoSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new VideoSplitter(*this);
    }
};
```

- 通过传递this指针在拷贝构造函数中实现深拷贝

```c++
class MainForm : public Form
{
    ISplitter*  prototype;//原型对象

public:
    
    MainForm(ISplitter*  prototype){
        this->prototype=prototype;
    }
    
	void Button1_Click(){

		ISplitter * splitter=
            prototype->clone(); //克隆原型
        
        splitter->split();
        
        

	}
};
```

- 在MainForm中通过 prototype原型对象进行对象克隆

## Builder 构建器（少用）

### 动机（Motivation）  

- 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常**由各个部分的子对象**用一定的算法**构成**；由于需求的变化，这个复杂对象的**各个部分经常面临着剧烈的变化**，但是将它们**组合在一起的算法却相对稳定**。  
- 如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？ 

### 模式定义

- 将一个复杂对象的**构建**与其**表示**相**分离**，使得**同样的构建过程**(稳定)可以**创建不同的表示**(变化)。  

### 结构（Structure）

![image-20210313083201159](https://i.loli.net/2021/03/13/jZrJIvP5D2W6iOn.png)

### 要点总结  

- Builder 模式主要用于“**分步骤**构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。  
- 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动  。
- 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#) 。  

### 伪码实现

```c++

class House{
    //....
};

class HouseBuilder {
public:
    House* GetResult(){
        return pHouse;
    }
    virtual ~HouseBuilder(){}
protected:
    
    House* pHouse;
	virtual void BuildPart1()=0;
    virtual void BuildPart2()=0;
    virtual void BuildPart3()=0;
    virtual void BuildPart4()=0;
    virtual void BuildPart5()=0;
	
};

class StoneHouse: public House{
    
};

class StoneHouseBuilder: public HouseBuilder{
protected:
    
    virtual void BuildPart1(){
        //pHouse->Part1 = ...;
    }
    virtual void BuildPart2(){
        
    }
    virtual void BuildPart3(){
        
    }
    virtual void BuildPart4(){
        
    }
    virtual void BuildPart5(){
        
    }
    
};


class HouseDirector{
    
public:
    HouseBuilder* pHouseBuilder;
    
    HouseDirector(HouseBuilder* pHouseBuilder){
        this->pHouseBuilder=pHouseBuilder;
    }
    
    House* Construct(){
        
        pHouseBuilder->BuildPart1();
        
        for (int i = 0; i < 4; i++){
            pHouseBuilder->BuildPart2();
        }
        
        bool flag=pHouseBuilder->BuildPart3();
        
        if(flag){
            pHouseBuilder->BuildPart4();
        }
        
        pHouseBuilder->BuildPart5();
        
        return pHouseBuilder->GetResult();
    }
};
```

- HouseBuilder相当于Builder负责各个**子对象**的构建
- House和HouseBuilder分离，实现复杂对象的构建与其表示相分离  

- HouseDirector相当于Director负责组建对象构建流程

# “对象性能”模式

- 面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。
- 典型模式
  - Singleton
  - Flyweight

## Singleton 单例模式

### 动机

- 在软件系统中，经常有这样一些特殊的类，**必须保证它们在系统中只存在一个实例**，才能确保它们的逻辑正确性、以及良好的效率。
- 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例? 
- 这应该是类设计者的责任，而不是使用者的责任。

### 模式定义

- 保证一个类仅有一个实例，并提供一个该实例的全局访问点。

### 结构（Structure）

![image-20210313092749158](https://i.loli.net/2021/03/13/4AfO8dIoTZBiN6C.png)

### 要点总结

- Singleton模式中的实例构造器可以设置为protected以允许子类派生。
- Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。
- 如何实现多线程环境下安全的Singleton ?注意对**双检查锁**的正确实现。

### 伪码实现

> 懒汉式

```c++
class Singleton{
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static Singleton* getInstance();
    static Singleton* m_instance;
};

Singleton* Singleton::m_instance=nullptr;

//线程非安全版本
Singleton* Singleton::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}


//线程安全版本，但锁的代价过高
Singleton* Singleton::getInstance() {
    Lock lock;
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}



//双检查锁，但由于内存读写reorder不安全
Singleton* Singleton::getInstance() {
    
    if(m_instance==nullptr){
        Lock lock;
        if (m_instance == nullptr) {
            m_instance = new Singleton();
        }
    }
    return m_instance;
}


//C++ 11版本之后的跨平台实现 (volatile)
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);
    if (tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton;
            std::atomic_thread_fence(std::memory_order_release);//释放内存fence
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

- 在这种懒汉式实现中，双检查锁由于内存读写reorder不安全
- 因为编译器在new一个Singleton对象的过程中分3步，第一步分配内存，第二步构造Singleton对象，第三步将内存地址赋值给m_instance
- 但是由于编译器的优化可能导致内存读写reorder，并且这种情况还时长发生，此时：第一步还是分配内存，而第二步是将内存地址赋值给m_instance，最后一步才是构造Singleton对象。
- 此时如果有两个线程threadA和threadB，threadA先获取锁，但是在实例化对象的过程中产生了内存读写reorder，先将内存地址赋值给了m_instance，此时m_instance不空，而此时恰巧threadB进入条件判断，发现m_instance不空于是就返回对象了，但是此时的m_instance的指向的内容是错误的。
- 因此造成了线程的不安全

> 饿汉式

- 线程安全

```c++
class singleton{
protected:
    singleton(){}
private:
    static singleton* p;
public:
    static singleton* initance();
};

singleton* singleton::p = new singleton; // 在单例类定义的时候就进行实例化

singleton* singleton::initance(){
   return p;
}
```

## Flyweight 享元模式

## 动机

- 在软件系统采用纯粹对象方案的问题在于**大量细粒度**的对象会很快充斥在系统中，从而带来很高的运行时代价—主要指内存需求方面的代价。

## 模式定义

- 运用**共享技术**有效地支持大量细粒度的对象。

## 结构（Structure）

![image-20210313100307950](https://i.loli.net/2021/03/13/NVmsK87i2TInvcH.png)

### 要点总结

- 面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向**对象的代价问题**，一般不触及面向对象的抽象性问题。
- Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在真体实现方面，要注意对象状态的处理。
- 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大?这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。

### 伪码实现

```c++
class Font {
private:

    //unique object key
    string key;
    
    //object state
    //....
    
public:
    Font(const string& key){
        //...
    }
};

class FontFactory{
private:
    map<string,Font* > fontPool;
    
public:
    Font* GetFont(const string& key){

        map<string,Font*>::iterator item = fontPool.find(key);
        
        if(item!=footPool.end()){
            return fontPool[key];
        }
        else{
            Font* font = new Font(key);
            fontPool[key]= font;
            return font;
        }

    }
    
    void clear(){
        //...
    }
};
```

# “接口隔离”模式

- 在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层**间接**（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。
- 典型模式
  - Facade
  - Proxy
  - Adapter
  - Mediator

## Facade 门面模式

### 系统间耦合的复杂度

![image-20210314101131441](https://i.loli.net/2021/03/14/XOK4lgJ6tLMb2Rm.png)

### 动机（Motivation）

- 上述A方案的问题在于组件的**客户和组件**中各种复杂的子系统**有了过多的耦合**，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。
- 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

### 模式定义

- 为子系统中的一组接口提供一个一致（稳定）的界面Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）

### 结构（Structure）

![image-20210314101542816](https://i.loli.net/2021/03/14/nrROqusCBZfpceE.png)

### 要点总结

- 从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对子组件内部与外部客户程序来说，送到了一种“解耦”的效果——**内部子系统的住何变化不会影响到Facade接口的变化。**
- Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是**一种架构设计模式**。
- Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的**内部应该是“相互耦合关系比较大的一系列组件”**，而不是一个简单的功能集合。

## Proxy 代理模式

### 动机 (Motivation )

- 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），**直接访问会给使用者、或者系统结构带来很多麻烦。**
- 如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性?增加一层间接层是软件开发中常见的解决方式。

### 模式定义

- 为其他对象提供—种代理以控制(隔离，使用接口)对这个对象的访问。

### 结构（Structure）

![image-20210314103453018](https://i.loli.net/2021/03/14/rtZNaHRAvsMpYOw.png)

### 要点总结

- **“增加一层间接层”**是软件系统中对许多复杂问题的一种常见解决方法， 在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。
- 具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层,在架构层次对对象做proxy。
- Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。

### 伪码实现

```c++
class ISubject{
public:
    virtual void process();
};


class RealSubject: public ISubject{
public:
    virtual void process(){
        //....
    }
};

class ClientApp{
    
    ISubject* subject;
    
public:
    
    ClientApp(){
        subject=new RealSubject();
    }
    
    void DoTask(){
        //...
        subject->process();
        
        //....
    }
};
```

- 在实际过程中可能无法直接使用RealSubject对象

```c++
class ISubject{
public:
    virtual void process();
};


//Proxy的设计
class SubjectProxy: public ISubject{
    
    
public:
    virtual void process(){
        //对RealSubject的一种间接访问
        //....
    }
};

class ClientApp{
    
    ISubject* subject;
    
public:
    
    ClientApp(){
        subject=new SubjectProxy();
    }
    
    void DoTask(){
        //...
        subject->process();
        
        //....
    }
};
```

- proxy类实现对RealSubject的一种间接访问

## Adapter适配器模式

### 动机（Motivation）

- 在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。
- 如何应对这种“迁移的变化”?如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口?

### 模式定义

- 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。

### 结构（Structure）

![image-20210314111816747](https://i.loli.net/2021/03/14/52FnixbIQ1GLZvO.png)

### 要点总结

- Adapter模式主要应用于“希望复用一些**现存的类**，但是**接口**又与复用坏境要求**不一致**的情况"，在遗留代码复用、类库移等方面非常有用。
- GoF 23定义了两种Adapter模式的实现结构:**对象适配器**和**类适配器**。但**类适配器**采用**“多继承”**的实现方式，**一般不推荐使用**。对象适配器采用“**对象组合**”的方式，更符合松耦合精神。
- Adapter模式可以实现的非常灵活，不必拘泥于Gof23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。

### 伪码实现

```c++
//目标接口（新接口）
class ITarget{
public:
    virtual void process()=0;
};

//遗留接口（老接口）
class IAdaptee{
public:
    virtual void foo(int data)=0;
    virtual int bar()=0;
};

//遗留类型
class OldClass: public IAdaptee{
    //....
};

// 对象适配器
class Adapter: public ITarget{ //继承
protected:
    IAdaptee* pAdaptee;//组合
    
public:
    
    Adapter(IAdaptee* pAdaptee){
        this->pAdaptee=pAdaptee;
    }
    
    virtual void process(){
        int data=pAdaptee->bar();
        pAdaptee->foo(data);
        
    }
    
    
};


//类适配器
class Adapter: public ITarget,
               protected OldClass{ //多继承
               
               
}


int main(){
    IAdaptee* pAdaptee=new OldClass();
    
    
    ITarget* pTarget=new Adapter(pAdaptee);
    pTarget->process();
    
}

class stack{
    deqeue container;
    
};

class queue{
    deqeue container;
    
};
```

- 对象适配器Adapter通过继承新接口（ITarget）和组合老接口（IAdaptee）的方式实现。

## Mediator 中介者（少用）

### 动机（ Motivation）

- 在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。
- 在这种情况下，我们可使用“中介对象”来**管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系**，从而更好地抵御变化。

### 模式定义

- 用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（**编译时依赖→运行时依赖**），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。

### 结构（Structure）

![image-20210317161341461](https://i.loli.net/2021/03/17/9DgasuLWNdkA2UZ.png)

### 要点定义

- 将多个对象间复杂的关联关系解耦， Mediator模式将多个对象间的控制逻辑进行集中管理，**变“多个对象互相关联”为“多个对象和一个中介者关联”**，简化了系统的维护，抵御了可能的变化。
- 随着控制逻辑的复杂化， Mediator具体对象的实现可能相当复杂。这时候可以对 Mediator对象进行分解处理。
- **Facade模式**是解耦**系统间**（**单向**）的对象关联关系； **Mediator模式**是解耦**系统内**各个对象之间（**双向**）的关联关系。

# “状态变化”模式

- 在组件构建过程中，某些对象的**状态**经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化“模式为这一问题提供了一种解决方案。
- 典型模式
  - State
  - Memonto

## State 状态模式

### 动机（ Motivation）

- 在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。
- 如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？

### 模式定义

- 允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。

### 结构（ Structure）

![image-20210318081150866](https://i.loli.net/2021/03/18/zsHfwrjZMqLeB9g.png)

### 要点总结

- State模式将所有与一个特定状态相关的行为都放入一个 State的子类对象中，在对象状态切换时，**切换相应的对象，但同时维持State的接口**，这样实现了具体操作与状态转换之间的解耦。
- 为不同的状态引入不同的对象使得状态转换变得更加明确，而且，可以保证不会出现状态不一致的情况，因为转换是原子性的——要么彻底转换过来，要么不转换。
- 即如果Stae对象没有实例变量，那么各个上下文可以共享同一个State对象，。从而节省对象开销。

### 伪码演示

>网络处理

```c++
enum NetworkState
{
    Network_Open,
    Network_Close,
    Network_Connect,
};

class NetworkProcessor{
    
    NetworkState state;

public:
    
    void Operation1(){
        if (state == Network_Open){

            //**********
            state = Network_Close;
        }
        else if (state == Network_Close){

            //..........
            state = Network_Connect;
        }
        else if (state == Network_Connect){

            //$$$$$$$$$$
            state = Network_Open;
        }
    }

    public void Operation2(){

        if (state == Network_Open){
            
            //**********
            state = Network_Connect;
        }
        else if (state == Network_Close){

            //.....
            state = Network_Open;
        }
        else if (state == Network_Connect){

            //$$$$$$$$$$
            state = Network_Close;
        }
    
    }

    public void Operation3(){

    }
};
```

> 状态模式

```c++
class NetworkState{

public:
    NetworkState* pNext;
    virtual void Operation1()=0;
    virtual void Operation2()=0;
    virtual void Operation3()=0;

    virtual ~NetworkState(){}
};


class OpenState :public NetworkState{
    
    static NetworkState* m_instance;
public:
    static NetworkState* getInstance(){
        if (m_instance == nullptr) {
            m_instance = new OpenState();
        }
        return m_instance;
    }

    void Operation1(){
        
        //**********
        pNext = CloseState::getInstance();
    }
    
    void Operation2(){
        
        //..........
        pNext = ConnectState::getInstance();
    }
    
    void Operation3(){
        
        //$$$$$$$$$$
        pNext = OpenState::getInstance();
    }
    
    
};

class CloseState:public NetworkState{ }
//...


class NetworkProcessor{
    
    NetworkState* pState;
    
public:
    
    NetworkProcessor(NetworkState* pState){
        
        this->pState = pState;
    }
    
    void Operation1(){
        //...
        pState->Operation1();
        pState = pState->pNext;
        //...
    }
    
    void Operation2(){
        //...
        pState->Operation2();
        pState = pState->pNext;
        //...
    }
    
    void Operation3(){
        //...
        pState->Operation3();
        pState = pState->pNext;
        //...
    }

};
```

- 这样在增加状态的时候，不需要更改代码，而是扩展子类，比如增加等待状态
- class WaitState : public NetworkState{……}  然后具体实现操作就可以了

## Memento 备忘录（过时）

### 动机（Motivation）

- 在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够**回溯到对象之前处于某个点时的状态**。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。
- 如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。

### 模式定义

- 在不破坏封装性的前提下，捕获一个对象的內部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态

### 结构（Structure）

![image-20210318085134256](https://i.loli.net/2021/03/18/N8QAFr4Mhyu2eHk.png)

### 要点总结

- **备忘录**（ Memento）存储**原发器**（ Originator）对象的内部状态，在需要时恢复原发器状态。
- **Memento模心是信息隐藏**，即 Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界（ Memento）。
- 由于代语言运行时（如#、Jaa等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现 Memento模式。

### 伪码演示

```c++
class Memento
{
    string state;
    //..
public:
    Memento(const string & s) : state(s) {}
    string getState() const { return state; }
    void setState(const string & s) { state = s; }
};



class Originator
{
    string state;
    //....
public:
    Originator() {}
    Memento createMomento() {
        Memento m(state);
        return m;
    }
    void setMomento(const Memento & m) {
        state = m.getState();
    }
};



int main()
{
    Originator orginator;
    
    //捕获对象状态，存储到备忘录
    Memento mem = orginator.createMomento();
    
    //... 改变orginator状态
    
    //从备忘录中恢复
    orginator.setMomento(memento);

}
```

- 备忘录模式属于轻量级模式，在现代来看有些过时，但是其思想是不变的，都是**信息隐藏**，

# “数据结构”模式

- 常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。
- 典型模式
  - Composite
  - lterator
  - Chain of Resposibility

## Composite模式

### 动机（ Motivation）

- 软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。
- 如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象样来处理复杂的对象容器？

###  模式定义

- 将对象组合成**树形结构**以表示“部分-整体”的层次结构， Composite使得用户对**单个对象和组合对象的使用具有致性（稳定）**。

### 结构（Structure）

![image-20210318092953350](https://i.loli.net/2021/03/18/sQ2XfKmcZOgYMei.png)

### 要点总结

- Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。
- 将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客戶代码将与纯粹的抽象接口——而非对象容器的内部实现结构发生依赖，从而更能应对变化
- Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。

### 伪码演示

```c++
#include <iostream>
#include <list>
#include <string>
#include <algorithm>

using namespace std;

class Component
{
public:
    virtual void process() = 0;
    virtual ~Component(){}
};

//树节点
class Composite : public Component{
    
    string name;
    list<Component*> elements;
public:
    Composite(const string & s) : name(s) {}
    
    void add(Component* element) {
        elements.push_back(element);
    }
    void remove(Component* element){
        elements.remove(element);
    }
    
    void process(){
        
        //1. process current node
        
        
        //2. process leaf nodes
        for (auto &e : elements)
            e->process(); //多态调用
         
    }
};

// 叶子节点
class Leaf : public Component{
    string name;
public:
    Leaf(string s) : name(s) {}
            
    void process(){
        //process current node
    }
};


void Invoke(Component & c){
    //...
    c.process();
    //...
}


int main()
{

    Composite root("root");
    Composite treeNode1("treeNode1");
    Composite treeNode2("treeNode2");
    Composite treeNode3("treeNode3");
    Composite treeNode4("treeNode4");
    Leaf leat1("left1");
    Leaf leat2("left2");
    
    root.add(&treeNode1);
    treeNode1.add(&treeNode2);
    treeNode2.add(&leaf1);
    
    root.add(&treeNode3);
    treeNode3.add(&treeNode4);
    treeNode4.add(&leaf2);
    
    Invoke(root);
    Invoke(leaf2);
    Invoke(treeNode3);
  
}
```

- 代码的核心是for (auto &e : elements){e->process(); }//多态调用，使得Invoke接口可以一致处理。

## Iterator迭代器模式(过时)

## 动机（Motivation）

- 在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在**不暴露其内部结构**的同时，可以让外部客户代码**透明地访问**其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作″提供了可能。
- 使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式

### 模式定义

- 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。

### 结构（Structure）

![image-20210318101918754](https://i.loli.net/2021/03/18/sdIg3C2iBhwRXaL.png)

### 要点总结

- 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
- 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
- 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

### 伪码演示

```c++
template<typename T>
class Iterator
{
public:
    virtual void first() = 0;
    virtual void next() = 0;
    virtual bool isDone() const = 0;
    virtual T& current() = 0;
};

template<typename T>
class MyCollection{
    
public:
    
    Iterator<T> GetIterator(){
        //...
    }
    
};

template<typename T>
class CollectionIterator : public Iterator<T>{
    MyCollection<T> mc;
public:
    
    CollectionIterator(const MyCollection<T> & c): mc(c){ }
    
    void first() override {
        
    }
    void next() override {
        
    }
    bool isDone() const override{
        
    }
    T& current() override{
        
    }
};

void MyAlgorithm()
{
    MyCollection<int> mc;
    
    Iterator<int> iter= mc.GetIterator();
    
    for (iter.first(); !iter.isDone(); iter.next()){
        cout << iter.current() << endl;
    }
    
}
```

- 对于现代c++而言，这种模式已经过时，因为所有的遍历都是通过虚函数实现的，属于**运行时多态**，效率较低，而STL中采用的是模板实现**编译时多态**，效率比较高。

## Chain of Resposibility职责链（少用）

### 动机（ Motivation）

- 在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。
- 如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。

### 模式定义

- 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

### 结构（ Structure）

![image-20210318104534801](https://i.loli.net/2021/03/18/4yOiNF8QIpYRo1k.png)

### 要点总结

- Chain of responsibility 模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发动者与接受者的耦合有可能出现”变化脆弱“的症状，职责链的目的就是将二者解耦，从而更好地应对变化。
- 应用了Chain of responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。
- 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。

### 伪码演示

```c++
#include <iostream>
#include <string>

using namespace std;

enum class RequestType
{
    REQ_HANDLER1,
    REQ_HANDLER2,
    REQ_HANDLER3
};

class Reqest
{
    string description;
    RequestType reqType;
public:
    Reqest(const string & desc, RequestType type) : description(desc), reqType(type) {}
    RequestType getReqType() const { return reqType; }
    const string& getDescription() const { return description; }
};

class ChainHandler{
    
    ChainHandler *nextChain;
    void sendReqestToNextHandler(const Reqest & req)
    {
        if (nextChain != nullptr)
            nextChain->handle(req);
    }
protected:
    virtual bool canHandleRequest(const Reqest & req) = 0;
    virtual void processRequest(const Reqest & req) = 0;
public:
    ChainHandler() { nextChain = nullptr; }
    void setNextChain(ChainHandler *next) { nextChain = next; }
    
    // 使用链表形式，向上请求，异常抛出机制和这种方式相似
    void handle(const Reqest & req)
    {
        if (canHandleRequest(req))
            processRequest(req);
        else
            sendReqestToNextHandler(req);
    }
};


class Handler1 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest & req) override
    {
        return req.getReqType() == RequestType::REQ_HANDLER1;
    }
    void processRequest(const Reqest & req) override
    {
        cout << "Handler1 is handle reqest: " << req.getDescription() << endl;
    }
};
        
class Handler2 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest & req) override
    {
        return req.getReqType() == RequestType::REQ_HANDLER2;
    }
    void processRequest(const Reqest & req) override
    {
        cout << "Handler2 is handle reqest: " << req.getDescription() << endl;
    }
};

class Handler3 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest & req) override
    {
        return req.getReqType() == RequestType::REQ_HANDLER3;
    }
    void processRequest(const Reqest & req) override
    {
        cout << "Handler3 is handle reqest: " << req.getDescription() << endl;
    }
};

int main(){
    Handler1 h1;
    Handler2 h2;
    Handler3 h3;
    h1.setNextChain(&h2);
    h2.setNextChain(&h3);
    
    Reqest req("process task ... ", RequestType::REQ_HANDLER3);
    h1.handle(req);
    return 0;
}
```

- h1—>h2—>h3，下面在h1中发送”RequestType::REQ_HANDLER3“请求，h1会向上抛出请求，直到h3处理请求。
- sendReqestToNextHandler：负责向上连接
- setNextChain：负责设置下一个连接
- handle：函数负责向上回溯

# “行为变化”模式

- 在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式**将组件的行为和组件本身进行解耦**，从而支持组件行为的变化，实现两者之间的松耦合。
- 典型模式
  - Command
  - Visitor

## Command 命令模式（过时）

### 动机（ Motivation）

- 在软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合——比如需要对行为进行“记录、撤销/重（ undo/redo）、事务″等处理，这种无法抵御变化的紧耦合是不合适的。
- 在这种情况下，如何将“行为请求者”与“行为实现者′解耦？将—组行为抽象为对象，可以实现二者之间的松耦合。

### 模式定义

- 将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

### 结构（Structure）

![image-20210318131734363](https://i.loli.net/2021/03/18/gLF2XRTcvzjnDWM.png)

### 要点总结

- Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象“。
- 实现 Command接口的具体命令对象 Concretecommand有时候根据需要可能会保存一些额外的状态信息。通过使用 Composite模式，可以将多个“"命令”封装为一个“复合命令” Macrocommand。
- Command模式与C++中的**函数对象**有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范更严格，但有性能损失；**C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高**

### 伪码实现

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Command
{
public:
    virtual void execute() = 0;
};

class ConcreteCommand1 : public Command
{
    string arg;
public:
    ConcreteCommand1(const string & a) : arg(a) {}
    void execute() override
    {
        cout<< "#1 process..."<<arg<<endl;
    }
};

class ConcreteCommand2 : public Command
{
    string arg;
public:
    ConcreteCommand2(const string & a) : arg(a) {}
    void execute() override
    {
        cout<< "#2 process..."<<arg<<endl;
    }
};
        
        
class MacroCommand : public Command
{
    vector<Command*> commands;
public:
    void addCommand(Command *c) { commands.push_back(c); }
    void execute() override
    {
        for (auto &c : commands)
        {
            c->execute();
        }
    }
};
        
        
int main()
{

    ConcreteCommand1 command1(receiver, "Arg ###");
    ConcreteCommand2 command2(receiver, "Arg $$$");
    
    MacroCommand macro;
    macro.addCommand(&command1);
    macro.addCommand(&command2);
    
    macro.execute();

}
```

## Visitor 访问器（少用）

### 动机（Motivation）

- 在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。
- 如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？

### 模式定义

- 表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。

### 结构（Structure）

![image-20210318134353166](https://i.loli.net/2021/03/18/GzJavrKgmNUuRBy.png)

### 要点总结

- Visitor模式通过所谓的**双重分发（double dispatch）**来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层级结构上的各个类动态添加新的操作（支持变化）
- 所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：**第一个为accept方法的多态辨析**；**第二个为visitElementX方法的多态辨析**。
- Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类）会导致Visitor类的改变。因此Visitor模式适用于**“Element”类层次结构稳定**，而其中的**操纵却经常面临频繁改动**。

### 伪码演示

> 普通模式

```c++
#include <iostream>
using namespace std;

class Visitor;


class Element
{
public:
    virtual void Func1() = 0;
    
    virtual void Func2(int data)=0;
    virtual void Func3(int data)=0;
    //...
    
    virtual ~Element(){}
};

class ElementA : public Element
{
public:
    void Func1() override{
        //...
    }
    
    void Func2(int data) override{
        //...
    }
    
};

class ElementB : public Element
{
public:
    void Func1() override{
        //***
    }
    
    void Func2(int data) override {
        //***
    }
    
};
```

- 违背了开闭原则

> visitor模式

```c++
#include <iostream>
using namespace std;

class Visitor;


class Element
{
public:
    virtual void accept(Visitor& visitor) = 0; //第一次多态辨析

    virtual ~Element(){}
};

class ElementA : public Element
{
public:
    void accept(Visitor &visitor) override {
        visitor.visitElementA(*this);
    }
    

};

class ElementB : public Element
{
public:
    void accept(Visitor &visitor) override {
        visitor.visitElementB(*this); //第二次多态辨析
    }

};


class Visitor{
public:
    virtual void visitElementA(ElementA& element) = 0;
    virtual void visitElementB(ElementB& element) = 0;
    
    virtual ~Visitor(){}
};

// ==================================

// 扩展1
class Visitor1 : public Visitor{
public:
    void visitElementA(ElementA& element) override{
        cout << "Visitor1 is processing ElementA" << endl;
    }
        
    void visitElementB(ElementB& element) override{
        cout << "Visitor1 is processing ElementB" << endl;
    }
};
     
// 扩展2
class Visitor2 : public Visitor{
public:
    void visitElementA(ElementA& element) override{
        cout << "Visitor2 is processing ElementA" << endl;
    }
    
    void visitElementB(ElementB& element) override{
        cout << "Visitor2 is processing ElementB" << endl;
    }
};
        
    
int main()
{
    Visitor2 visitor;
    ElementB elementB;
    elementB.accept(visitor);// double dispatch
    
    ElementA elementA;
    elementA.accept(visitor);

    return 0;
}
```

- Double Dispatch 实现调用visitor2中的elementB方法

# “领域规则”模式

- 在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。
- 典型模式
  - Interpreter

## Interpreter解释器（少用）

### 动机（Motivation）

- 在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。
- 在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建—个解释器来解释这样的句子，从而达到解决问题的目的。

### 模式定义

- 给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。

### 结构（Structure）

![image-20210318144240487](https://i.loli.net/2021/03/18/jR2oJhXmQr1V7Tv.png)



### 要点总结

- Interpreter模式的应用场合是 Interprete模式应用中的难点，只有满定“业务规则频繁变化”，且类似的结构不断重现，并且容易抽象为语法规则的问题”才适合使用 Interpreter模式。
- 用 Interpreter模式来表示文法规则，从而可以使用面向对象技来方便地“扩展”文法。
- Interpreter模式比较适合简单的文法表示，对于复杂的文法表Interperte会产生比较大的类层次结构，需要求助于语析生成器这样的标准工具。

![image-20210318144210586](https://i.loli.net/2021/03/18/PTUjftpK6GJDYcS.png)

### 伪码演示

```c++
#include <iostream>
#include <map>
#include <stack>

using namespace std;
 
class Expression {
public:
    virtual int interpreter(map<char, int> var)=0;
    virtual ~Expression(){}
};

//变量表达式
class VarExpression: public Expression {
    
    char key;
    
public:
    VarExpression(const char& key)
    {
        this->key = key;
    }
    
    int interpreter(map<char, int> var) override {
        return var[key];
    }
    
};

// 符号表达式
class SymbolExpression : public Expression {
    
    // 运算符左右两个参数
protected:
    Expression* left;
    Expression* right;
    
public:
    SymbolExpression( Expression* left,  Expression* right):
        left(left),right(right){
        
    }
    
};

// 加法运算
class AddExpression : public SymbolExpression {
    
public:
    AddExpression(Expression* left, Expression* right):
        SymbolExpression(left,right){
        
    }
    int interpreter(map<char, int> var) override {
        return left->interpreter(var) + right->interpreter(var);
    } 
    
};

// 减法运算
class SubExpression : public SymbolExpression {
    
public:
    SubExpression(Expression* left, Expression* right):
        SymbolExpression(left,right){
        
    }
    int interpreter(map<char, int> var) override {
        return left->interpreter(var) - right->interpreter(var);
    }
    
};


Expression*  analyse(string expStr) {
    
    stack<Expression*> expStack;
    Expression* left = nullptr;
    Expression* right = nullptr;
    for(int i=0; i<expStr.size(); i++)
    {
        switch(expStr[i])
        {
            case '+':
                // 加法运算
                left = expStack.top();
                right = new VarExpression(expStr[++i]);
                expStack.push(new AddExpression(left, right));
                break;
            case '-':
                // 减法运算
                left = expStack.top();
                right = new VarExpression(expStr[++i]);
                expStack.push(new SubExpression(left, right));
                break;
            default:
                // 变量表达式
                expStack.push(new VarExpression(expStr[i]));
        }
    }
   
    Expression* expression = expStack.top();

    return expression;
}

void release(Expression* expression){
    
    //释放表达式树的节点内存...
}

int main(int argc, const char * argv[]) {
    
    
    string expStr = "a+b-c+d-e";
    map<char, int> var;
    var.insert(make_pair('a',5));
    var.insert(make_pair('b',2));
    var.insert(make_pair('c',1));
    var.insert(make_pair('d',6));
    var.insert(make_pair('e',10));

    
    Expression* expression= analyse(expStr);
    
    int result=expression->interpreter(var);
    
    cout<<result<<endl;
    
    release(expression);
    
    return 0;
}
```

# 设计模式总结

## 一个目标

- 管理变化，提高复用

## 两种手段

- 分解和抽象

## c++对象模型

![image-20210318153323684](https://i.loli.net/2021/03/18/zrpvtP5E8qg1i9H.png)

- 在设计模式中基本都是采用第三种设计方法，采用组合对象指针的方式，利用多态的机制实现设计的灵活性。
- 第一种继承和第二种组合的方式都缺乏灵活性，内存结构基本相同。

## 关注变化点和稳定点

![image-20210318153544832](https://i.loli.net/2021/03/18/yovLnVYwgHaQReW.png)

## 什么时候不用模式

- 代码可读性很差时
- 需求理解还浅时
- 变化还没有显现时
- 不是系统的关键依赖点
- 项目没有复用价值时
- 项目将要发布时

## 经验之谈

- 不要为模式而模式
- 关注抽象类&接口
- 理清变化点和稳定点
- 审视依赖关系
- 要有 Framework和 Application的区隔思维
- 良好的设计是演化的结果

## 设计模式的成长之路

- 手中无剑心中无剑”：见模式而不知
- “手中有剑心中无剑”：可以识别模式，作为应用开发人员使用模式
- 手中有剑心中有剑”：作为框架开发人员为应用设计某些模式
- 手中无剑心中有剑”：忘掉模式，只有原则